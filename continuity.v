(* This file provides a definition of continuity of functions between spaces of the form
Q -> A for some arbitrary types Q and A. It also proves some basic Lemmas about this notion.*)
From mathcomp Require Import all_ssreflect.
Require Import multi_valued_functions.
Require Import FunctionalExtensionality ClassicalChoice.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section CONTINUITY_DEFINITION.
Context (Q A Q' A' : Type).
(* Q is for questions, A is for answers*)
Notation B := (Q -> A).
Notation B' := (Q' -> A').
(* B is for Baire space. B should be thought of as a language: An element of B is a - not
neccessarily meaningful - conversation: when a question q: Q, is asked in such a conversation,
some information phi(q): I is returned as answer. Usually the questions and answers can be
encoded as natural numbers, which will give the usual Baire space nat->nat. *)

(* Two conversations phi and psi coincide on a list L of questions about the object, if they
give the same answers for any question that is included in L. *)
Fixpoint equal_on (phi psi: B) L :=
  match L with
    | nil => True
    | cons s K => (phi s = psi s) /\ (equal_on phi psi K)
  end.
Notation "phi 'and' psi 'coincide_on' L" := (equal_on phi psi L) (at level 2).

Lemma coin_and_list_in (phi psi: B):
	forall L, phi and psi coincide_on L <-> (forall q, List.In q L -> phi q = psi q).
Proof.
elim=>//.
move => q L [] ih1 ih2.
split => ass.
	move => q' listin.
	case listin => ass'.
		by rewrite -ass'; apply: ass.1.
	apply: ih1 => //.
	by apply ass.2.
split; first by apply ass;left.
apply ih2 => q' listin.
by apply ass; right.
Qed.

Lemma coin_sym phi psi L:
	phi and psi coincide_on L <-> psi and phi coincide_on L.
Proof.
move: L.
elim => //.
by split; by split; [by rewrite H0.1| by apply/ H; apply H0.2].
Qed.

Lemma coin_trans phi psi psi' L:
	phi and psi coincide_on L -> psi and psi' coincide_on L -> phi and psi' coincide_on L.
Proof.
move: L.
elim => //.
move => q L ih phicpsi psicpsi'.
split; try apply: ih; [by rewrite phicpsi.1 psicpsi'.1|apply: phicpsi.2|apply: psicpsi'.2].
Qed.

(* The set of meaningful conversations in a language is a subset of the Baire space corre-
sponding to that language. For instance if one is given a dictionary, that asigns to each
pair of a question q and am answer i a property P on an abstract space X, i.e. a set of objects
x such that i a valid answer to the question q about x, one may consider the subset of all
conversations that are descriptions of an object in the sense that they do not provide any
contradictory information and uniquely identify an abstract object *)

Context (F: B ->> B').
(* F is a multivalued function and a good example of such a function is a translation between
dictionaires. I.e. the case where (dom F) and (range F) are generated by some dictionaries D
and D' and for a description phi of x according to D, the set F(phi) consists of all valid
descriptions x with respect to the dictionary D'. *)

Definition determines L phi q' :=
	forall (psi : B), phi and psi coincide_on L ->
  	forall Fphi Fpsi : B', F phi Fphi -> F psi Fpsi -> Fphi q' = Fpsi q'.

(* Such a translation is continuous if for each question about an object in the second
language, an answer can be found from a dscription in the first language by asking a finite
number of questions. *)
Definition is_cont :=
  forall phi q', exists L, determines L phi q'.

Definition is_mod mf := forall phi q', determines (mf phi q') phi q'.
End CONTINUITY_DEFINITION.

Notation "phi '\and' psi '\coincide_on' L" := (equal_on phi psi L) (at level 2).
Notation "F '\is_continuous'" := (is_cont F) (at level 2).
Notation "mf '\is_modulus_of' F" := (is_mod F mf) (at level 2).

Section CONTINUITY_LEMMAS.
Context (Q A Q' A' : Type).
Notation B := (Q -> A).
Notation B' := (Q' -> A').

Lemma coin_ref (phi: B):
	forall L, phi \and phi \coincide_on L.
Proof.
	by elim.
Qed.

Lemma app_coincide L K (phi psi: B):
	phi \and psi \coincide_on (L ++ K) <-> (phi \and psi \coincide_on L /\ phi \and psi \coincide_on K).
Proof.
split.
	move: L.
	elim; first by replace (nil ++ K) with (K); split.
	move => a L ih.
	replace ((a :: L) ++ K) with ((a :: L)%SEQ ++ K)%list by trivial.
	rewrite -(List.app_comm_cons L K a).
	move => [ass1 ass2].
	split; try apply ih; try apply ass2.
	by split => //; apply ih; apply ass2.
move: L.
elim; first by move => [_ coin]; replace (nil ++ K) with (K).
move => a L ih [[ass1 ass2] ass3].
replace ((a :: L) ++ K) with ((a :: L)%SEQ ++ K)%list by trivial.
rewrite -(List.app_comm_cons L K a).
by split; try apply ih; try apply ass2.
Qed.

Lemma continuous_extension (F G: B ->> B'):
	G \tightens F -> G \is_continuous -> F \is_single_valued -> F \is_continuous.
Proof.
move => GeF Gcont Fsing phi q'.
move: (Gcont phi q') => [] L Lprop.
exists L => psi pep Fphi Fpsi FphiFphi FpsiFpsi.
move: GeF (@tightening_of_single_valued B B' F G Fsing GeF) => _ GeF.
by apply: (Lprop psi) => //;[apply: (GeF phi Fphi)|apply: (GeF psi Fpsi)].
Qed.

Lemma cont_to_sing (F: B ->> B'):
	F \is_continuous -> F \is_single_valued.
Proof.
move => cont phi Fphi Fpsi FphiFphi FphiFpsi.
apply functional_extensionality => a.
move: cont (cont phi a) => _ [L] cont.
have eq: (forall K, phi \and phi \coincide_on K) by elim.
by rewrite -((cont phi (eq L) Fpsi)).
Qed.

Lemma exists_modulus (F: B ->> B'):
	F \is_continuous -> exists mf, mf \is_modulus_of F.
Proof.
move => cont.
set R := (fun phiq L => determines F L phiq.1 phiq.2).
have cond: forall phiq, exists L, R phiq L.
	move => [phi q'].
	move: (cont phi q') => [L] prop.
	by exists L => psi /= H; apply: prop.
move: cond (choice R cond) => _ [mf] cond.
exists (fun phi q => mf (phi, q)) => phi q psi.
by apply: cond.
Qed.

Lemma continuous_composition Q'' A'' (F: B ->> B') (G: B' ->> (Q'' -> A'')):
	F \is_continuous -> G \is_continuous -> G o F \is_continuous.
Proof.
move => Fcont Gcont.
move => phi q''.
move: (exists_modulus Fcont) => [mf] ismod.
case (classic (exists Fphi, F phi Fphi)); last first => ass.
	exists nil => psi _ Fpsi Fpsi' [] [] Fphi [] FphiFphi _ _ _.
	by exfalso; apply ass; exists Fphi.
have [Fphi FphiFphi]:= ass.
have [L Lprop]:= (Gcont Fphi q'').
set gather := fix gather K := match K with
	| nil => nil
	| cons q' K' => app (mf phi q') (gather K')
end.
exists (gather L) => psi coing.
case: (classic (exists Fpsi, F psi Fpsi)).
	move => ex GFphi GFpsi GFphiGFphi [] [] Fpsi [] FpsiFpsi GFpsiGFpsi prop.
	have coin: Fphi \and Fpsi \coincide_on L.
		specialize (Lprop Fpsi).
		move: L Lprop coing.
		elim=> // a L ih assump coin.
		move: coin ((app_coincide (mf phi a) (gather L) phi psi).1 coin) => _ [coin1 coin2].
		split; first by apply: (ismod phi a psi) => //.
		apply ih => // coin'.
		apply assump.
		by split; try apply (ismod phi a psi).
	apply/ Lprop; [by apply coin| |done].
	move: GFphiGFphi => [] [] Fphi' [] FphiFphi' GFphiFphi' _.
	by rewrite (cont_to_sing Fcont FphiFphi FphiFphi').
move => false GFphi GFpsi _ [] [] Fpsi [] FpsiFpsi.
by exfalso; apply false; exists Fpsi.
Qed.
End CONTINUITY_LEMMAS.